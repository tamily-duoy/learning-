# 2.2内置类型  
自定义类型（user_defined）、内置类型（built_in）。  
内置函数是复合数据结构的基本单元；会被编译器、解释器特别对待，如，核心级别的指令和性能优化，专门设计的高效缓存等。  
作为自带电池（batteries_included）的python，只用基本数据类型就可以完成相对复杂的算法逻辑。  
内置的基本数据类型：（1）数字、序列、映射、集合；（2）可变(mutable)、不可变(immutable)。  
![built_in](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/built_in.png)  
标准库collections.abc，列出了相关类型的抽象基类，可以根据类型的抽象基类判断类型的行为方式。  
```python
import collections.abc  

issubclass(str,collections.abc.Sequence)
>>>True  

issubclass(str,collections.abc.MutableSequence)
>>>False
```
在日常开发时，应该优先选择内置类型（标准库）。  
除了考虑性能原因，还能提高跨平台兼容性，以提高保障。  
引入不成熟的第三方代码，会提升整体复杂度，增加潜在错误风险，不利于代码升级和维护。  


## 2.2.1 整数      
pyhton3将原来的 int、long 两种整数类型合并为 int，采用变长结构。优点是简化了语言规则，缺点是，会导致更多的内存开销。  
简化后，python3也就不再支持表示 long类型的L常量后缀。  
变长结构允许我们创建超大的天文数字，理论上仅仅受可以分配的内存大小的限制。  
```python  
x=1
type(x)
>>> <class 'int'>
import sys
sys.getsizeof(x)
>>>28  
  
y=1<<10000
y
>>>1995063116880...76
type(y)
>>> <class 'int'>
  
sys.getsizeof(y)
>>> 1360

```  
从输出结果来看，尽管都是 int 类型，但 x 和 y所占的内存大小差别巨大。在底层实现上，通过不定长结构体（variable_length_structure）按需分配内存。  
对于较长数字，以分隔标记，但逗号在python语句中有特殊含义，因此用下划线表示，且不限分隔位数（下划线已经不可用）。  
```python  
78,654,321         #逗号是tuple的语法，不能用于千分位表达
>>>(78, 654, 321)
  
"{:,}".format(56381779049)
>>>'56,381,779,049'
```
除了十进制外，数字还可以用二进制（bin）、八进制（oct）、十六进制（hex）表示。下划线分隔符号同样适用于这些进制的字面量（下划线已不可用）。  
二进制可用来设计类似位图（bitmap）这类开关标记类型，系统管理命令chmod使用八进制设置访问权限，十六进制则常见于反汇编等逆向操作。  
八进制不再支持012这样的格式，只能以0o（或大写）前缀开头。  
```python  
0b110011          #bin
>>>51  

0o12              #oct
>>>10  

0x64              #hex
>>>100

```
  
转换：  
可以用内置函数将整数为指定进制字符串，或反向用 int还原。  
```python  
bin(8)
>>>'0b1000'  

oct(8)
>>>'0o10'  

hex(8)
>>>'0x8'
```
int函数默认十进制，会忽略空格、制表等空白符。如果指定进制，则可以省略相关进制前缀。  
```python  
int("0b1000",2)  
8  

int("0o10",8)
8  

int("0x8",16)
8
int("8",16)       #省略进制前缀
8
```
```python   
int(" 100 ")      #忽略多余空白符
>>>100  
  
int("\t100\t")    #忽略多余空白符
>>>100
```
用eval也能完成转换，即，把字符串当作普通表达式。但是，与直接以C实现的函数转换，性能要差很多，因为，动态运行需要额外编译和执行开销。  
```python  
eval("0o144")
>>>100
```
另一种转换操作是，将整数转换为字节数组，这种转换方式在二进制网络协议和文件读写中很常见。  
此时，需要指定字节序（byte_order），即，大小端（big_endian、little_endian）。  
无论什么类型的数据，在系统底层均以字节方式存储。以整数0x1234为例，可以分为两个字节，高位字节0x12和低位字节0x34。不同硬件架构会采取不同的存储顺序，高位在前（big_endian，大端）或低位在前（little_endian，小端），这与硬件架构的设计有关。  
日常较多的 Intel x86、AMD64 采用小端。ARM则两种都支持，ARM默认采用小端较多，也可以自行设定。此外，TCP/IP网络字节序采用大端，这属于协议，与硬件架构和操作系统无关。  
转换操作必须指定目标字节数组的大小，考虑到整数类型是变长结构，因此，通过二进制位长度计算。可以通过sys.byteorder获取当前系统字节序。  
```python  
x=0x1234
n=(x.bit_length()+8-1)//8       #计算按8位对齐所需的字节数
b=x.to_bytes(n,sys.byteorder)  
  
b.hex()                         #未运行成功
>>>'3412'  

hex(int.from_bytes(b,sys.byteorder))
>>>'0x1234'
```
  
运算符：  
支持常见的数学运算。  
```python  
3/2
>>>1.5
type(3/2)
>>><class 'float'>               #python2.7是 int类型
```
除法运算分 / 和 // 两种。 / 被称为True_Division，无论是否整除，总是返回浮点数； // 称为Floor_Division，会截掉小数部分，仅返回整数结果。  
```python  
4/2                              #True Division
>>> 2.0  

4//2                             #Floor Division
>>> 2

```
如果要获取余数，可以用取模运算符（mod）或者divmod函数。  
```python
5%2
>>> 1  

divmod(5,2)
>>> (2, 1)
```
python 3不再支持数字和非数字类型的比较操作。  
  
布尔：  
布尔是整数的子类型。即，True、False可以被当做数字来直接使用。  
```python  
issubclass(bool,int)
>>> True  

isinstance(True,int)
>>> True  

True==1
>>>True
True+1
>>>2
```  
在进行布尔转换时，数字零、空值（None）、空序列、空字典等，都被视为False，反之为True 。  
```python  
data=(0,0.0,None,"",list(),tuple(),dict(),set(),frozenset())
any(map(bool,data))
>>>False  
  
data=(True,0.0,None,"",list(),tuple(),dict(),set(),frozenset())
any(map(bool,data))
>>>True
```  
对于自定义类型，可以通过重写 __bool__ 或者 __len__ 方法，来影响bool转换结果。  
  
枚举：  
python语言里面没有枚举（enum）的定义，而是通过标准库来实现枚举。  
在多数语言中，枚举是面向编译器，类似于数字常量的存在。  
但是python的枚举比较复杂。首先，定义枚举类型，随后由内部代码生成枚举值实例；  
```python  
import enum
Color=enum.Enum("Color","BLACK YELLOW BLUE RED")   #报错  
isinstance(Color.Black,Color)                      #上步报错，该步无法执行
>>>True
  
list(Color)                                        #上步报错，该步无法执行
>>>  
```  
没有规定时，枚举值必须是整数。通过继承，可以将枚举值设置为任意类型。  
```python  
class X(enum.Enum):
    A="a"
    B=100
    C=[1,2,3]  

X.C
>>> <X.C: [1, 2, 3]>
```
枚举类型的内部以字典方式实现，每个枚举值都有 name 和 value 属性。可以通过名字或者值，查找对应枚举实例。  
```python  
X.B.name
>>>'B'
X.B.value
>>>100  
  
X["B"]
>>><X.B: 100>           #by_name
X([1,2,3])
>>><X.C: [1, 2, 3]>     #by_value

X([1,2])
>>>ValueError: [1, 2] is not a valid X
```  
按照字典规则，值（value）可以相同，但是名字（name）不允许重复。
```python  
class X(enum.Enum):
    A=1
    B=1  
    
class X(enum.Enum):
    A=1
    A=2  
>>>TypeError: Attempted to reuse key: 'A'
```  
当值相同时，无论是基于名字查找，还是基于值查找，都会返回第一个定义项。  
```python  
class X(enum.Enum):
    A=100
    B="b"
    C=100  
    
X.A
>>><X.A: 100>
X.C
>>><X.A: 100>  

X["C"]
>>><X.A: 100>
X(100)
>>><X.A: 100>
```  
为了避免值相同的枚举，可以用enum.unique装饰器定义枚举。  
与传统的的枚举常量相比，标准库提供了丰富的拓展，如，自增数字、标志位等。但这些拓展方法需要耗费额外内存和性能开销。  
  
内存：  
对于常用的小数字，解释器会在初始化时进行预缓存。在后续使用这些小数字时，直接将名字关联到这些缓存对象。  
这样的优点是，不需要创建实例对象，可以提高性能，节约内存开销。  
python3.6的预缓存范围是 [-5,256] 参见Object/longobject.c:_PyLong_Init。  

如果超出缓存范围，那么每次都要新建对象，这其中包括内存分配等操作。  
```python  
a=-5
b=-5
a is b
>>>True  

a=256
b=256
a is b
>>>True  

a=-6
b=-6
a is b
>>>False
  
a=257
b=257
a is b
>>>False
```  
python2对回收后的整数复用内存，不做收缩处理，因此，会造成大量的闲置内存驻留。  
python3改进了此设计，极大的减少了内存占用。  
可以使用psutil库测试操作系统不同阶段的RSS内存大小。
```python  
from __future__ import print_function
import psutil     #未安装包，待测试  
  
def rss():        #输出进程RSS内存大小
    m=psutil.Process().memory_info()
    print(m.rss >> 20,"MB")  

if __name__=="__main__":
    rss()         #起始内存占用
    x=list(range(10000000))  #使用列表持有海量数字对象 10^7
    rss()         #输出海量数字造成的内存开销 
    del x         #删除列表，回收数字对象
    rss()         #输出回收后的内存占用
  
python2.7  
>>>11MB
>>>323MB
>>>246MB  

python3.6
>>> 11MB  
>>>397MB  
>>>11MB
```  

## 2.2.2 浮点数  
默认float类型存储双精度（double）浮点数，可以表达16-17个小数位。  
```python  
1/3
>>>0.3333333333333333  
  
0.123456789012345678901234567890
>>>0.12345678901234568
```   
从实现方式来看，浮点数是用二进制存储的十进制的近似值。这可能导致执行结果与编码预期结果不符合。  
因此，对精度有严格要求的场合，应该选择固定精度类型。 
可以通过float.hex方法，输出实际存储值得十六进制格式的字符串，从而检查执行结果有什么不同。  
也可以用float.hex方法，实现浮点值得精确传递，避免精度丢失。  
```python  
0.1*3==0.3
>>>False  

(0.1*3).hex()            #两个值得存储内容，并不相同
>>>'0x1.3333333333334p-2'
(0.3).hex()
>>>'0x1.3333333333333p-2'  
  
s=(1/3).hex()
float.fromhex(s)
>>>0.3333333333333333   #反向转换回浮点数
```   
对于简单的比较操作，可以尝试将浮点数限制在有效的固定精度内。但是，因为round算法的实现原因，更准确的做法是用decimal.Decimal类型。  
```python  
round(0.1*3,2)==round(0.3,2)  #避免不确定性，左右都使用固定精度
>>>True  

round(0.1,2)*3==round(0.3,2)  #将round返回值作为操作数，导致精度再次丢失
>>>False
```   
不同类型的数字之间，可以直接用加减、比较运算。
```python  
1.1+2
>>>3.1
1.1<2
>>>True
1.1==1
>>>False
```   
  
转换：  
将整数、字符串转换为浮点数很简单，并且，能够自动处理字符串内的正负符号、空白符号。  
但是，当超出有效精度时，得到的结果会与字符串内容存在差异。  
```python  
float(100)
>>>100.0
float("-100.123")     #符号
>>>-100.123
float("\t100.123\n")  #空白符
>>>100.123
float("1.234E2")      #科学计数法
>>>123.4
float("0.1234567890123456789")
>>>0.12345678901234568
```   
将浮点数转换为整数时，可以直接截掉小数部分，或分别往大小两个方向取临近整数。  
```python  
int(2.6),int(-2.6)    #截掉小数部分
>>>(2, -2)  

from math import trunc,floor,ceil
trunc(2.6),trunc(-2.6)  #截断小数部分
>>>(2, -2)
floor(2.6),floor(-2.6)  #往小数字方向，取最近整数
>>>(2, -3)
ceil(2.6),ceil(-2.6)    #往大数字方向，取最近整数
>>>(3, -2)
```   
![float](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/float.png)  

十进制浮点数：  
float是基于硬件的二进制浮点类型。而decimal.Decimal是十进制实现的，最高可以提供十进制实现，最高可以提供28位有效精度。  
decimal.Decimal能准确表达十进制数和运算，不存在二进制近似值问题。  
```python  
1.1+2.2                 #结果与3.3近似
>>>3.3000000000000003
(0.1+0.1+0.1-0.3)==0    #二进制近似值计算结果与十进制预期不符
>>>False  

from decimal import Decimal
Decimal("1.1")+Decimal("2.2")
>>>Decimal('3.3')
(Decimal("0.1")+Decimal("0.1")+Decimal("0.1")-Decimal("0.3"))==0
>>>True
```  
在创建Decimal实例时，应该传入一个准确数值，如整数、字符串等。  
如果是float类型，那么构建之前，float的精度就已经丢失。  
```python  
Decimal(0.1)
>>>Decimal('0.1000000000000000055511151231257827021181583404541015625')  

Decimal("0.1")
>>>Decimal('0.1')
```  
需要时，可以通过上下文修改Decimal默认的28位精度。  
```python  
from decimal import Decimal,getcontext
getcontext()
>>>Context(prec=28, rounding=ROUND_HALF_EVEN, ... )
getcontext().prec=2
Decimal(1) / Decimal(3)
>>>Decimal('0.33')
```  
或者使用localcontext限制某个区域的精度。  
```python  
from decimal import localcontext
with localcontext() as ctx:    #在该范围内将精度修改为2，不会影响外部精度
    ctx.prec=2
    print(getcontext().prec)
    print(Decimal(1)/Decimal(3))    
>>>2
>>>0.33
```  
除非有明确需求，否则不要用Decimal替代float，因为，Decimal的运算速度更慢。  
    
四舍五入：  
同样因为近似值和精度问题，造成对float进行“四舍五入”（round）操作存在不确定性，会给结果造成不易察觉的陷阱。  
```python  
round(0.5)   #5舍
>>>0
round(1.5)   #5入
>>>2
```  
按照round算法规则，按临近数字距离远近来考虑是否进位。  
因此，四舍六入是确定的，相关问题集中在两边距离相等的5是否考虑进位，如果5后面有小数点，则必然进位。


```python  
round(0.5)   #与0、1距离相等，暂时不确定
>>>0  

round(0.5000000000000000000001)
>>>0
round(0.50000000001)
>>>1
```  
然后，考虑返回的是整数还是浮点数。如果是整数，则取临近的偶数。不同版本存在差异。  
```python  
round(0.5)
>>>0
round(1.5)
>>>2
round(2.5)
>>>2
```
应该谨慎对待此类行为差异，严格测试代码。  
如果依旧返回浮点数，结果则比较复杂。  
```python  
round(1.25,1)   #偶舍
>>>1.2
round(1.245,2)  #偶进
>>>1.25
round(2.675,2)  #都是奇数7，但有舍有进
>>>2.67
round(2.375,2)
>>>2.38
```  
官方文档解释，事出有因。  
我们可以改用Decimal，按照需求选取可控的进位方案。  
```python  
def roundx(x,n):
    return Decimal(x).quantize(Decimal(n),ROUND_HALF_UP)  
  
roundx("1.24",".1")
>>>Decimal('1.2')
roundx("1.25",".1")
>>>Decimal('1.3')
roundx("1.26",".1")
>>>Decimal('1.3')
  
roundx("1.245",".01")    #未运行成功1.245,2.675,2.375--1.25,2.68,2.38
>>>ecimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]
```  

## 2.2.3 字符串  
字符串存储Unicode文本，字符串是不可变序列类型。  
python3已经将文本和字符串彻底分离。  
  
Unicode是，为了解决跨语言、跨平台的转换盒处理需求，采用统一的编码方案，容纳不同国家地区的文字，以解决传统编码不兼容的问题。  
Unicode为每一个字符分配一个码点（code_point），对应的编码方案叫做通用字符集（universal_character_set，UCS）。  
依据编码的整数长度，编码又分为UCS-2、UCS-4两种，UCS-4为32位，可以容纳更多的字符。  
UCS只规定了字符和码点的对应关系，不会涉及如何显示、如何存储。  
  
UTF（Unicode_Transformation_Format），作用是，将码点整数转换为计算机可存储的字节格式。现有UTF-8、UTF-16、UTF-32多种方案。  
UTF-8采用变长格式，与ASCII兼容，因此使用广泛；对于以英文为主的内容，UTF-8可以获得最好的存储效率。  
采用两字节等长的UTF-16，有更长的处理效率，常常用于执行编码。  
UTF可以在文本头部插入BOM（byte_order_mark）标志，以表明字节序信息，用来区分大小端（BE、LE）。有UTF-16、UTF-32。  
```python  
s="汉字"
len(s)
>>>2  
  
hex(ord("汉"))    #code point
>>>'0x6c49'
chr(0x6c49)
>>>'汉'
ascii("汉字")     #对non-ASCII进行转义
>>>"'\\u6c49\\u5b57'"
```   
字符串字符（literal）以成对的 ' 或 " 或可以跨行的'''语法组成，自动合并相邻字符串的字符。  
' 或 "：通常用 " 标示，如果引文内用 " 语句，则其外用 ' 标示可以避免转义。  
字符串的字符，支持转义、八进制、十六进制、或Unicode格式字符。  
 ' 或 " 还可以表示单个字符。  
```python  
"h\x69,\u6C49\U00005B57"
>>>'hi,汉字'
```   
Unicode格式的大小写不能混用，\u表示16位的整数；\U表示32位的整数。
```python  
"It's my life"       #英文缩写
>>>"It's my life"  

'The report contained the "facts" of the case'
>>>'The report contained the "facts" of the case'   #引文包含 "，避免借助\转义

"hello"",""world"    #自动合并多个相邻的字符串的 字符
>>>'hello,world'  

"""                  #换行符、前导空格、空行，都是组成内容
    Beautiful is better than ugly.  
    Explict is better than implict.
    Simple is better than complex
"""
>>>'\n    Beautiful is better than ugly.\n    Explict is better than implict.\n    Simple is better than complex\n'
```   
在字符串的字符前面添加标志时，相当于，在指示python构建特定格式的字符串。  
最常用的原始字符串（r,raw_string），将 \ 视为字符内容，而不是视为转义标志；  
优点是，对于类似 构建win路径、正则表达式匹配模式之类 的文法字符串时，很有用。  
```python  
open(r"c:\Users\Administrator\Desktop\readme.txt")   #windows路径
>>><_io.TextIOWrapper name='c:\\Users\\Administrator\\Desktop\\readme.txt' mode='r' encoding='cp936'>  

import re
re.findall(r"\b\d+\b","a10 100")    #正则表达式
>>>['100']  

type(u"abc")                        #默认str就是Unicode，不用加前缀u
>>><class 'str'>   
type("abc")
>>><class 'str'>  

type(b"abc")                        #构建字节数组
>>><class 'bytes'>
```   
  
字符串的操作：  
* 1.支持加法、乘法，来拼接字符串；  
```python  
s="hello"
s+=",world"
s
>>>'hello,world'  
  
"-"*10
>>>'----------'
```  
编译器会尝试在编译期间直接计算出字符串的字符的拼接结果，这样就避免了运行时开销。  
缺点是，这种优化程度有限，并不总是有效。  
```python  
def test():
    a="x"+"y"+"z"
    b="a"*10
    return a,b  
    
import dis
dis.dis(test)   
>>>  2           0 LOAD_CONST               7 ('xyz')          #直接给出结果，省略加法运算
>>>              2 STORE_FAST               0 (a)
>>>  3           4 LOAD_CONST               8 ('aaaaaaaaaa')   #省略乘法运算
>>>              6 STORE_FAST               1 (b)
>>>  4           8 LOAD_FAST                0 (a)
>>>             10 LOAD_FAST                1 (b)
>>>             12 BUILD_TUPLE              2
>>>             14 RETURN_VALUE
```  



* 2.多个动态字符串拼接，应该优先使用join、format方式；  
与多次加法运算、多次分配内存(字符串是不可变对象)相比，join这类函数可以预先计算出总长度，一次性分配内存，最后直接复制内存数据填充。  
另外，format将固定模板内容与变量分离，易于阅读与维护。  
```python  
username="yuhen"
datetime="2018110"
"/data/"+username+"/message/"+datetime+".txt"   #糟糕的方式
>>>'/data/yuhen/message/2018110.txt'  
  
tmp1="/data/{user}/message/{time}.txt"          #模板单独维护
tmp1.format(user=username,time=datetime)        #无需考虑参数的次序
>>> '/data/yuhen/message/2018110.txt'
```   

对比加法、join拼接字母的性能差异：  
提供简单的验证方法  
```python  
import string,profile
x=list(string.ascii_uppercase)  

@profile
def test_add():
    s=""
    for c in x:
        s+=c
    return s  
    
@profile
def test_join():
    return "".join(x)
  
>>>test_add()       #profile.run(test_add())
>>>test_join()      #profile.run(test_join())
```  
输出：  
![result](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/result.jpg)  
![result](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/result2.jpg)
注：line_profile、memory_profile使用方法，见[11测试]  
* 3.判断是否包含子串，in、not in；  
```python  
"py" in "python"
>>>True  

"Py" in "python"
>>>False
```  
* 4.作为序列类型，可以索引序列号，来访问字符串的单个字符或某一片段。正索引从0开始；负索引从-1开始；   
作为序列类型，字符串可以索引序列号，访问字符串的单个字符或者某一片段。  
python3支持负索引，也就是反向从尾部索引，以-1开始；正向索引，以0开始。  
```python  
s="0123456789"  

s[2]
>>>'2'    

s[-1]
>>>'9'  

s[2:6]
>>>'2345'  

s[2:-2]
>>>'234567'
```    
切片（slice），指使用2个索引号，来表示一个序列片段。切片可以返回字符串的子串。  
无论以哪种方式，返回与原字符串内容不同的子串时，都可能需要重新分配内存，并复制数据。  
(1)与原字符串内容相同、不同时，字符串对象各自的构建情形：  
```python   
s="-"*1024  

s1=s[10:100]         #内容不同
s2=s[:]              #内容相同
s3=s.split(",")[0]   #内容相同

s1 is s           #内容不同，重新构建新对象
>>>False  

s2 is s           #内容相同，直接引用原字符串对象
>>>True  

s3 is s           #内容相同，直接引用原字符串对象
>>>True
```  
(2)与原字符串内容相同、不同时，字符串对象各自的内存分配情形：  
```python  
@profile
def test():
    a=x[10:-10]
    b=x.split(",")
    return a,b
  
x="0,"*(1<<20)
test()
```  
输出：  
![result](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/result3.jpg)  
内存分配行为和具体的python版本相关。  
* 5. 对于复杂的文本处理，可以使用正则表达式、专业扩展库等，如NLTK、TextBlob等。  

字符串类型包含丰富的处理方法，可以满足大多数操作的需要。  


转换：  
* 1.不同编码间，进行转换；  
字符串可以与数字、Unicode码点、不同编码间，进行转换。不同编码间进行转换最为常见。  
python3使用bytes、bytearray存储字节序列，改进了之前版本混用两者这一点。  
 ```python  
 s="汉字"
b=s.encode("utf-16")      # to bytes
b.decode("utf-16")        # to unicode str
>>>'汉字' 
 ```
* 2.要处理BOM信息，可以直接通过导入codecs模块解决；  
```python  
s="汉字"  

s.encode("utf-16").hex()
>>>'fffe496c575b'

import codecs
codecs.BOM_UTF16_LE.hex()           #BOM标志
>>>'fffe'  

codecs.encode(s,"utf-16be").hex()   #按照指定BOM转换
>>>'6c495b57'   
codecs.encode(s,"utf-16le").hex()
>>>'496c575b'
```    

* 3.python3默认编码不再是ASCII码，不需要额外设置；
```python  
import sys 
sys.getdefaultencoding()
>>>'utf-8'
```  
  
  
格式化：  
python有多种字符串格式化的方式。  
* 1.  python3.6新增f-strings支持，f-strings支持是大多数脚本语言的标配；  
使用f前缀标志，解释器会解释大括号{}里面的字段、表达式，然后在上下文命名空间中，查找同名对象，对同名对象进行值替换。  
格式化控制，遵循format规范，也更加易读、简洁。  
```python  
x=10
y=20  

f"{x}+{y}={x+y}"             #f-strings
>>>'10+20=30'  

"{}+{}={}".format(x,y,x+y)   # str.format
>>>'10+20=30'
```  

* 2.除了可以使用运算符，字符串格式化也可以通过函数调用来实现；  
```python  
x=10
f"{type(x)}"
>>>"<class 'int'>"          #函数调用，来实现字符串格式化
```  
完整的format格式化，用位置序号或字段名匹配参数 来进行值替换，同时，可以为格式化添加 对齐、填充、精度等控制。  
从某种程度来说，f-strings有点像format的增强语法糖。    

![format]()    

f-strings和format对比：  
f-strings类，模板方式更加灵活，一定程度上，分离了输出样式与数据来源；  
缺点是，f-strings与上下文名字耦合，这会造成，模板内容与代码必须保持同步修改；  
format，采取 序号与主键匹配的方式，可以避开名字耦合；同时，format支持静态分析工具检查代码；  
format的缺点是，不支持表达式。
  
```python  
#手工序号和自动序号  
"{0} {1} {0}".format("a",10)
>>>'a 10 a'  

"{} {}".format(1,2)     #自动序号，不能与手工序号混用
>>>'1 2'  
  
#主键
"{x} {y}".format(x=100,y=[1,2,3])
>>>'100 [1, 2, 3]'  
 
#属性和索引  
x.name="jack"           #报错int.name  

"{0.name}".format(x)    #报错int.name      #对象属性---应该返回Jack  

"{0[2]}".format([1,2,3,4])                #索引
>>>'3'

#宽位、补位    
"{0:#08b}".format(5)
>>>'0b000101'  

#数字    
"{:06.2f}".format(1.234)                  #保留2位小数
>>>'001.23'  

"{:,}".format(123456789)                  #千分位
>>>'123,456,789'  
  
#对齐
"[{:^10}]".format("abc")                  #居中
>>>'[   abc    ]'  

"[{:.<10}]".format("abc")                 #左对齐，以点填充
>>>'[abc.......]'
```  
不建议使用printf方法；  
标准库的string.Template功能弱，不建议使用。  
  
池化：  
字符串可能是进程中实例数量最多的类型之一，因为，名字就是字符串实例。  
由于，相同变量名会重复出现在不同的命名空间中，因此，有必要共享实例。共享内容相同的不可变对象，不会造成任何问题。  
关键是做到共享实例的同时，节约内存，且省去创建新实例的开销。  
python的做法是实现一个字符串池（intern）。  
池负责管理实例，使用者引用实例。  
建立字符串池的潜在优点是，从字符串池返回的字符串，只需要比较指针就能知道内容是否相同，而不需要额外计算。  
因此，可以用池来提升哈希表等类似结构的查找性能。  
```python  
"__name__" is sys.intern("__name__")
>>>True
```    
池，可以加入以常量方式出现的变量名、字符串的字符、动态生成的字符串。  
池可以保证每次都引用同一对象，不会有额外的创建和分配操作。  
```python  
a="hello,world!"
b="hello,world!"  

a is b           #不同实例
>>>False  

import sys       #相同实例
sys.intern(a) is sys.intern("hello,world!")
>>>True
```  
一旦失去所有外部引用，池内的字符串对象一样会被回收。  
```python  
a=sys.intern("hello,world!")
id(a)
>>>54266480
id(sys.intern("hello,world!"))    #有外部引用
>>>54266480
  
del a                             #删除外部引用后不被回收----应是被回收

id(sys.intern("hello,world!"))    #从id值相同可以看出，字符串是边入池边新建---应是，id值不同可以看出，字符串是新建后入池的。
>>>54266480
```  
字符串池的实现算法简单，就是简单的字典结构，见Object/unicodeobject.c:PyUnicode_InterInPlace。  
做大数据处理时，可能需要创建海量主键，用字符串池机制，有助于减少对象数量，节约大量内存。  
当然，也可以选择更高效的数据结构，而不一定是系统内置的字符串池。  


## 2.2.4 字节数组    
从底层实现来说，所有数据都是二进制字节序列。为了更好地表达某个逻辑，我们将其抽象成不同类型。  
一体两面：对于字节序列，我们关注存储、传输方式；对于面向类型时，则关注其抽象属性。  
当str只是表示字符串时，专门用于二进制数据处理的类型也会出现。  
python2引入例如bytearray字节数组，python3引入了只读版本的bytes。  
同样是不可变序列类型，bytes与str操作非常类似。  
```python  
b"abc"
>>>b'abc'   

bytes("汉字","utf-8")
>>>b'\xe6\xb1\x89\xe5\xad\x97'
```  
```python  
a=b"abc"
b=a+b"def"
b
>>>b'abcdef'  

b.startswith(b"abc")
>>>True  

b.upper()
>>>b'ABCDEF'
```  
bytes一次性分配内存；bytearray可以按需求分配内存，适合作为可读可写缓冲区，必要的话，可以提前为bytearray分配内存，以避免中途扩张造成额外消耗。  
```python  
b=bytearray(b"ab")  

len(b)
>>>2  

b.append(ord("c"))
b.extend(b"de")
b
>>>bytearray(b'abcde')
```  
支持加法、乘法运算。  
```python  
b"abc"+b"123"
>>>b'abc123'  

b"abc"*2
>>>b'abcabc'  

a=bytearray(b"abc")
a*2
>>>bytearray(b'abcabc')  

a+=b"123"
a
>>>bytearray(b'abc123')
```
内存视图：   
如果要引用字节数据的某个片段时，就需要考虑：数据是否有复制行为，是否能同步修改。  
```python  
a=bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16])  

x=a[2:5]     #引用片段
x
>>>bytearray(b'\x12\x13\x14')  

a[3]=0xEE    #修改原数据
a
>>>bytearray(b'\x10\x11\x12\xee\x14\x15\x16')  

x            #并未同步发生变更，显然是数据复制
>>>bytearray(b'\x12\x13\x14')
```  
为什么要引用某个片段，而不是整个对象？  
以自定义网络协议为例，通常网络协议由标准头、数据体组成。  
如果要验证数据是否被修改，显然不能将整个包作为参数传递给验证函数，因为，这就要求该验证函数了解协议的包结构，显然不合理。  
同时，复制数据体可能导致重大性能开销，得不偿失。  
  
由于python没有指针，且存在内存安全模型的限制。  
因此，必须借助一种名为内存视图（memory_views）的方式来访问底层数据。  
内存视图要求目标对象支持缓冲协议（buffer_protocol）。内存视图直接引用目标内存，没有额外复制行为。  
因此，内存视图可以读取最新数据。在目标对象允许的情况下，还可以执行写操作。  
常见支持视图的操作有Bytes、bytearray、array.array，以及Numpy的某些类型。  
```python  
a=bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16])  

v=memoryview(a)      #完整视图

x=v[2:5]            #视图片段
x.hex()
'121314'  

a[3]=0xee           #对原数据修改，可以通过视图观察到

x.hex()
>>>'12ee14'  

x[1]=0x13          #因为引用相同的内存区域，因此，可以通过视图修改原数据
a
>>>bytearray(b'\x10\x11\x12\x13\x14\x15\x16')
```  
视图片段有自己的索引范围。读写操作以视图索引为准，不得超出限制。  
能不能通过视图修改数据，需要视原对象是否允许来确定。  
```python  
a=b"\x10\x11"      #bytes是不可变类型
v=memoryview(a)  

v[1]=0xEE
>>>TypeError: cannot modify read-only memory
```  
如果要复制视图数据，可以调用tobytes、tolist方法。  
复制试图得到的复制后的数据与原对象无关，不会影响视图自身。  
```python  
a=bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16])
v=memoryview(a)
x=v[2:5]  

b=x.tobytes()     #复制并返回视图数据
b
>>>b'\x12\x13\x14'  

a[3]=0xEE         #对原数据进行修改

b                 #不影响复制数据
>>>b'\x12\x13\x14'
```   
内存视图提供内存管理手段：  
首先，通过bytearray预申请很大一块内存，然后用视图方式将不同片段交给不同逻辑使用。  
由于逻辑不能越界访问，因此，可以实现简易的内存分配器模式。  
python是一种限制较多的语言，如果能合理使用视图，则可以在不适用cbytes等复杂扩展的前提下，改善算法性能。  
可以借助memoryview.cast、struct.unpack将字节数组转换为目标类型。  

## 2.2.5 列表    
单单从操作方式上来看，列表像是数组、链表的综合体。  
除了按索引访问外，还支持插入、追加、删除等操作，完全可以当做队列、栈来使用。  
如果不考虑性能问题，列表简单易用，且功能完善。  
```python  
x=[1,2]
x[1]
>>>2  

x.insert(0,0)
x
>>>[0, 1, 2]  

x.reverse()
x
>>>[2, 1, 0]  
```   
queue
```python



```  



## 2.2.6 字典    

## 2.2.7 集合
