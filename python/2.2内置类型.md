# 2.2内置类型  
自定义类型（user_defined）、内置类型（built_in）。  
内置函数是复合数据结构的基本单元；会被编译器、解释器特别对待，如，核心级别的指令和性能优化，专门设计的高效缓存等。  
作为自带电池（batteries_included）的python，只用基本数据类型就可以完成相对复杂的算法逻辑。  
内置的基本数据类型：（1）数字、序列、映射、集合；（2）可变(mutable)、不可变(immutable)。  
![built_in](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/built_in.png)  
标准库collections.abc，列出了相关类型的抽象基类，可以根据类型的抽象基类判断类型的行为方式。  
```python
import collections.abc  

issubclass(str,collections.abc.Sequence)
>>>True  

issubclass(str,collections.abc.MutableSequence)
>>>False
```
在日常开发时，应该优先选择内置类型（标准库）。  
除了考虑性能原因，还能提高跨平台兼容性，以提高保障。  
引入不成熟的第三方代码，会提升整体复杂度，增加潜在错误风险，不利于代码升级和维护。  


## 2.2.1 整数      
pyhton3将原来的 int、long 两种整数类型合并为 int，采用变长结构。优点是简化了语言规则，缺点是，会导致更多的内存开销。  
简化后，python3也就不再支持表示 long类型的L常量后缀。  
变长结构允许我们创建超大的天文数字，理论上仅仅受可以分配的内存大小的限制。  
```python  
x=1
type(x)
>>> <class 'int'>
import sys
sys.getsizeof(x)
>>>28  
  
y=1<<10000
y
>>>1995063116880...76
type(y)
>>> <class 'int'>
  
sys.getsizeof(y)
>>> 1360

```  
从输出结果来看，尽管都是 int 类型，但 x 和 y所占的内存大小差别巨大。在底层实现上，通过不定长结构体（variable_length_structure）按需分配内存。  
对于较长数字，以分隔标记，但逗号在python语句中有特殊含义，因此用下划线表示，且不限分隔位数（下划线已经不可用）。  
```python  
78,654,321         #逗号是tuple的语法，不能用于千分位表达
>>>(78, 654, 321)
  
"{:,}".format(56381779049)
>>>'56,381,779,049'
```
除了十进制外，数字还可以用二进制（bin）、八进制（oct）、十六进制（hex）表示。下划线分隔符号同样适用于这些进制的字面量（下划线已不可用）。  
二进制可用来设计类似位图（bitmap）这类开关标记类型，系统管理命令chmod使用八进制设置访问权限，十六进制则常见于反汇编等逆向操作。  
八进制不再支持012这样的格式，只能以0o（或大写）前缀开头。  
```python  
0b110011          #bin
>>>51  

0o12              #oct
>>>10  

0x64              #hex
>>>100

```
  
转换：  
可以用内置函数将整数为指定进制字符串，或反向用 int还原。  
```python  
bin(8)
>>>'0b1000'  

oct(8)
>>>'0o10'  

hex(8)
>>>'0x8'
```
int函数默认十进制，会忽略空格、制表等空白符。如果指定进制，则可以省略相关进制前缀。  
```python  
int("0b1000",2)  
8  

int("0o10",8)
8  

int("0x8",16)
8
int("8",16)       #省略进制前缀
8
```
```python   
int(" 100 ")      #忽略多余空白符
>>>100  
  
int("\t100\t")    #忽略多余空白符
>>>100
```
用eval也能完成转换，即，把字符串当作普通表达式。但是，与直接以C实现的函数转换，性能要差很多，因为，动态运行需要额外编译和执行开销。  
```python  
eval("0o144")
>>>100
```
另一种转换操作是，将整数转换为字节数组，这种转换方式在二进制网络协议和文件读写中很常见。  
此时，需要指定字节序（byte_order），即，大小端（big_endian、little_endian）。  
无论什么类型的数据，在系统底层均以字节方式存储。以整数0x1234为例，可以分为两个字节，高位字节0x12和低位字节0x34。不同硬件架构会采取不同的存储顺序，高位在前（big_endian，大端）或低位在前（little_endian，小端），这与硬件架构的设计有关。  
日常较多的 Intel x86、AMD64 采用小端。ARM则两种都支持，ARM默认采用小端较多，也可以自行设定。此外，TCP/IP网络字节序采用大端，这属于协议，与硬件架构和操作系统无关。  
转换操作必须指定目标字节数组的大小，考虑到整数类型是变长结构，因此，通过二进制位长度计算。可以通过sys.byteorder获取当前系统字节序。  
```python  
x=0x1234
n=(x.bit_length()+8-1)//8       #计算按8位对齐所需的字节数
b=x.to_bytes(n,sys.byteorder)  
  
b.hex()                         #未运行成功
>>>'3412'  

hex(int.from_bytes(b,sys.byteorder))
>>>'0x1234'
```
  
运算符：  
支持常见的数学运算。  
```python  
3/2
>>>1.5
type(3/2)
>>><class 'float'>               #python2.7是 int类型
```
除法运算分 / 和 // 两种。 / 被称为True_Division，无论是否整除，总是返回浮点数； // 称为Floor_Division，会截掉小数部分，仅返回整数结果。  
```python  
4/2                              #True Division
>>> 2.0  

4//2                             #Floor Division
>>> 2

```
如果要获取余数，可以用取模运算符（mod）或者divmod函数。  
```python
5%2
>>> 1  

divmod(5,2)
>>> (2, 1)
```
python 3不再支持数字和非数字类型的比较操作。  
  
布尔：  
布尔是整数的子类型。即，True、False可以被当做数字来直接使用。  
```python  
issubclass(bool,int)
>>> True  

isinstance(True,int)
>>> True  

True==1
>>>True
True+1
>>>2
```  
在进行布尔转换时，数字零、空值（None）、空序列、空字典等，都被视为False，反之为True 。  
```python  
data=(0,0.0,None,"",list(),tuple(),dict(),set(),frozenset())
any(map(bool,data))
>>>False  
  
data=(True,0.0,None,"",list(),tuple(),dict(),set(),frozenset())
any(map(bool,data))
>>>True
```  
对于自定义类型，可以通过重写 __bool__ 或者 __len__ 方法，来影响bool转换结果。  
  
枚举：  
python语言里面没有枚举（enum）的定义，而是通过标准库来实现枚举。  
在多数语言中，枚举是面向编译器，类似于数字常量的存在。  
但是python的枚举比较复杂。首先，定义枚举类型，随后由内部代码生成枚举值实例；  
```python  
import enum
Color=enum.Enum("Color","BLACK YELLOW BLUE RED")   #报错  
isinstance(Color.Black,Color)                      #上步报错，该步无法执行
>>>True
  
list(Color)                                        #上步报错，该步无法执行
>>>  
```  
没有规定时，枚举值必须是整数。通过继承，可以将枚举值设置为任意类型。  
```python  
class X(enum.Enum):
    A="a"
    B=100
    C=[1,2,3]  

X.C
>>> <X.C: [1, 2, 3]>
```
枚举类型的内部以字典方式实现，每个枚举值都有 name 和 value 属性。可以通过名字或者值，查找对应枚举实例。  
```python  
X.B.name
>>>'B'
X.B.value
>>>100  
  
X["B"]
>>><X.B: 100>           #by_name
X([1,2,3])
>>><X.C: [1, 2, 3]>     #by_value

X([1,2])
>>>ValueError: [1, 2] is not a valid X
```  
按照字典规则，值（value）可以相同，但是名字（name）不允许重复。
```python  
class X(enum.Enum):
    A=1
    B=1  
    
class X(enum.Enum):
    A=1
    A=2  
>>>TypeError: Attempted to reuse key: 'A'
```  
当值相同时，无论是基于名字查找，还是基于值查找，都会返回第一个定义项。  
```python  
class X(enum.Enum):
    A=100
    B="b"
    C=100  
    
X.A
>>><X.A: 100>
X.C
>>><X.A: 100>  

X["C"]
>>><X.A: 100>
X(100)
>>><X.A: 100>
```  
为了避免值相同的枚举，可以用enum.unique装饰器定义枚举。  
与传统的的枚举常量相比，标准库提供了丰富的拓展，如，自增数字、标志位等。但这些拓展方法需要耗费额外内存和性能开销。  
  
内存：  
对于常用的小数字，解释器会在初始化时进行预缓存。在后续使用这些小数字时，直接将名字关联到这些缓存对象。  
这样的优点是，不需要创建实例对象，可以提高性能，节约内存开销。  
python3.6的预缓存范围是 [-5,256] 参见Object/longobject.c:_PyLong_Init。  

如果超出缓存范围，那么每次都要新建对象，这其中包括内存分配等操作。  
```python  
a=-5
b=-5
a is b
>>>True  

a=256
b=256
a is b
>>>True  

a=-6
b=-6
a is b
>>>False
  
a=257
b=257
a is b
>>>False
```  
python2对回收后的整数复用内存，不做收缩处理，因此，会造成大量的闲置内存驻留。  
python3改进了此设计，极大的减少了内存占用。  
可以使用psutil库测试操作系统不同阶段的RSS内存大小。
```python  
from __future__ import print_function
import psutil     #未安装包，待测试  
  
def rss():        #输出进程RSS内存大小
    m=psutil.Process().memory_info()
    print(m.rss >> 20,"MB")  

if __name__=="__main__":
    rss()         #起始内存占用
    x=list(range(10000000))  #使用列表持有海量数字对象 10^7
    rss()         #输出海量数字造成的内存开销 
    del x         #删除列表，回收数字对象
    rss()         #输出回收后的内存占用
  
python2.7  
>>>11MB
>>>323MB
>>>246MB  

python3.6
>>> 11MB  
>>>397MB  
>>>11MB
```  

## 2.2.2 浮点数  
默认float类型存储双精度（double）浮点数，可以表达16-17个小数位。  
```python  
1/3
>>>0.3333333333333333  
  
0.123456789012345678901234567890
>>>0.12345678901234568
```   
从实现方式来看，浮点数是用二进制存储的十进制的近似值。这可能导致执行结果与编码预期结果不符合。  
因此，对精度有严格要求的场合，应该选择固定精度类型。 
可以通过float.hex方法，输出实际存储值得十六进制格式的字符串，从而检查执行结果有什么不同。  
也可以用float.hex方法，实现浮点值得精确传递，避免精度丢失。  
```python  
0.1*3==0.3
>>>False  

(0.1*3).hex()            #两个值得存储内容，并不相同
>>>'0x1.3333333333334p-2'
(0.3).hex()
>>>'0x1.3333333333333p-2'  
  
s=(1/3).hex()
float.fromhex(s)
>>>0.3333333333333333   #反向转换回浮点数
```   
对于简单的比较操作，可以尝试将浮点数限制在有效的固定精度内。但是，因为round算法的实现原因，更准确的做法是用decimal.Decimal类型。  
```python  
round(0.1*3,2)==round(0.3,2)  #避免不确定性，左右都使用固定精度
>>>True  

round(0.1,2)*3==round(0.3,2)  #将round返回值作为操作数，导致精度再次丢失
>>>False
```   
不同类型的数字之间，可以直接用加减、比较运算。
```python  
1.1+2
>>>3.1
1.1<2
>>>True
1.1==1
>>>False
```   
  
转换：  
将整数、字符串转换为浮点数很简单，并且，能够自动处理字符串内的正负符号、空白符号。  
但是，当超出有效精度时，得到的结果会与字符串内容存在差异。  
```python  
float(100)
>>>100.0
float("-100.123")     #符号
>>>-100.123
float("\t100.123\n")  #空白符
>>>100.123
float("1.234E2")      #科学计数法
>>>123.4
float("0.1234567890123456789")
>>>0.12345678901234568
```   
将浮点数转换为整数时，可以直接截掉小数部分，或分别往大小两个方向取临近整数。  
```python  
int(2.6),int(-2.6)    #截掉小数部分
>>>(2, -2)  

from math import trunc,floor,ceil
trunc(2.6),trunc(-2.6)  #截断小数部分
>>>(2, -2)
floor(2.6),floor(-2.6)  #往小数字方向，取最近整数
>>>(2, -3)
ceil(2.6),ceil(-2.6)    #往大数字方向，取最近整数
>>>(3, -2)
```   
![float](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/2.2/float.png)  

十进制浮点数：  
float是基于硬件的二进制浮点类型。而decimal.Decimal是十进制实现的，最高可以提供十进制实现，最高可以提供28位有效精度。  
decimal.Decimal能准确表达十进制数和运算，不存在二进制近似值问题。  
```python  
1.1+2.2                 #结果与3.3近似
>>>3.3000000000000003
(0.1+0.1+0.1-0.3)==0    #二进制近似值计算结果与十进制预期不符
>>>False  

from decimal import Decimal
Decimal("1.1")+Decimal("2.2")
>>>Decimal('3.3')
(Decimal("0.1")+Decimal("0.1")+Decimal("0.1")-Decimal("0.3"))==0
>>>True
```  
在创建Decimal实例时，应该传入一个准确数值，如整数、字符串等。  
如果是float类型，那么构建之前，float的精度就已经丢失。  
```python  
Decimal(0.1)
>>>Decimal('0.1000000000000000055511151231257827021181583404541015625')  

Decimal("0.1")
>>>Decimal('0.1')
```  
需要时，可以通过上下文修改Decimal默认的28位精度。  
```python  
from decimal import Decimal,getcontext
getcontext()
>>>Context(prec=28, rounding=ROUND_HALF_EVEN, ... )
getcontext().prec=2
Decimal(1) / Decimal(3)
>>>Decimal('0.33')
```  
或者使用localcontext限制某个区域的精度。  
```python  
from decimal import localcontext
with localcontext() as ctx:    #在该范围内将精度修改为2，不会影响外部精度
    ctx.prec=2
    print(getcontext().prec)
    print(Decimal(1)/Decimal(3))    
>>>2
>>>0.33
```  
除非有明确需求，否则不要用Decimal替代float，因为，Decimal的运算速度更慢。  
    
四舍五入：  
同样因为近似值和精度问题，造成对float进行“四舍五入”（round）操作存在不确定性，会给结果造成不易察觉的陷阱。  
```python  
round(0.5)   #5舍
>>>0
round(1.5)   #5入
>>>2
```  
按照round算法规则，按临近数字距离远近来考虑是否进位。  
因此，四舍六入是确定的，相关问题集中在两边距离相等的5是否考虑进位，如果5后面有小数点，则必然进位。


```python  
round(0.5)   #与0、1距离相等，暂时不确定
>>>0  

round(0.5000000000000000000001)
>>>0
round(0.50000000001)
>>>1
```  
然后，考虑返回的是整数还是浮点数。如果是整数，则取临近的偶数。不同版本存在差异。  
```python  
round(0.5)
>>>0
round(1.5)
>>>2
round(2.5)
>>>2
```
应该谨慎对待此类行为差异，严格测试代码。  
如果依旧返回浮点数，结果则比较复杂。  
```python  
round(1.25,1)   #偶舍
>>>1.2
round(1.245,2)  #偶进
>>>1.25
round(2.675,2)  #都是奇数7，但有舍有进
>>>2.67
round(2.375,2)
>>>2.38
```  
官方文档解释，事出有因。  
我们可以改用Decimal，按照需求选取可控的进位方案。  
```python  
def roundx(x,n):
    return Decimal(x).quantize(Decimal(n),ROUND_HALF_UP)  
  
roundx("1.24",".1")
>>>Decimal('1.2')
roundx("1.25",".1")
>>>Decimal('1.3')
roundx("1.26",".1")
>>>Decimal('1.3')
  
roundx("1.245",".01")    #未运行成功1.245,2.675,2.375--1.25,2.68,2.38
>>>ecimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]
```  

## 2.2.3 字符串  
字符串存储Unicode文本，字符串是不可变序列类型。  
python3已经将文本和字符串彻底分离。  
  
Unicode是，为了解决跨语言、跨平台的转换盒处理需求，采用统一的编码方案，容纳不同国家地区的文字，以解决传统编码不兼容的问题。  
Unicode为每一个字符分配一个码点（code_point），对应的编码方案叫做通用字符集（universal_character_set，UCS）。  
依据编码的整数长度，编码又分为UCS-2、UCS-4两种，UCS-4为32位，可以容纳更多的字符。  
UCS只规定了字符和码点的对应关系，不会涉及如何显示、如何存储。  
  
UTF（Unicode_Transformation_Format），作用是，将码点整数转换为计算机可存储的字节格式。现有UTF-8、UTF-16、UTF-32多种方案。  
UTF-8采用变长格式，与ASCII兼容，因此使用广泛；对于以英文为主的内容，UTF-8可以获得最好的存储效率。  
采用两字节等长的UTF-16，有更长的处理效率，常常用于执行编码。  
UTF可以在文本头部插入BOM（byte_order_mark）标志，以表明字节序信息，用来区分大小端（BE、LE）。有UTF-16、UTF-32。  
```python  
s="汉字"
len(s)
>>>2  
  
hex(ord("汉"))    #code point
>>>'0x6c49'
chr(0x6c49)
>>>'汉'
ascii("汉字")     #对non-ASCII进行转义
>>>"'\\u6c49\\u5b57'"
```   
字符串字面量（literal）  


```python  

```   

```python  

```   

```python  

```   







## 2.2.4 字节数组    

## 2.2.5 列表    

## 2.2.6 字典    

## 2.2.7 集合
