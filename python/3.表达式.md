# 3.1 词法  
编辑器，用于编写完整逻辑；交互式工作方式属于调试器范围，与PDB工作方式类似。  
正式可分发的程序，由一到多个源码组成，每个源码各自对应一个运行期模块；模块内有很多语句，用于定义类型、创建实例、执行逻辑命令；语句中包含表达式，可以完成数据计算和函数调用。  
  
表达式（expression）由标识符、字面量、操作符组成。表达式完成运算、属性访问、函数调用等。表达式像数学公式那样，总是返回一个结果。  
语句（statement）则由一到多行代码组成，语句着重于逻辑过程，完成变量赋值、类型定义、控制执行流方向等。表达式是语句的一种，但是，语句不一定是表达式。  
归纳：表达式完成计算；语句执行逻辑。  

## 3.1.1 源文件  
python3默认编码格式改为UTF-8，源码文件开头不必再添加声明。但是，如果打算使用其他编码格式，则需要额外声明。  
  
执行：  
源文件的启动，只需要将入口文件名作为命令行参数传入即可。  
$ python3 main.py  
源文件启动，也可以在文件头部添加Shebang信息，以提示系统程序载入器用指定的解释器来执行。需要赋予该源码文件可执行权限。  
#!/usr/bin/env python  

print("您好")  
输出：  
chmod a+x main.py  
$ ./main.py  
不使用python的绝对路径，原因是，容错性差；建议以env从当前环境设置里查找与之匹配的解释器。当然，也可以指定解释器版本及相关执行参数。  
系统命令env通过环境变量PATH查找目标，这对于使用VirtualEnv之类的虚拟环境很有用。  
  
命令行：  
命令行参数，有解释器、程序两种，解释器以sys.flags读取，程序以sys.argv读取。   

```python  
import sys
print(sys.flags.optimize)   #解释器参数
>>>0  

print(sys.argv)             #程序启动参数
>>> ['F:\\pycharm\\PyCharm Community Edition 2017.1.2\\helpers\\pydev\\pydevconsole.py', '61632', '61633']
```  
对于简单测试代码，不需要创建文件或启用交互环境，直接在命令行以 -c 参数执行即可。  
$python -c "import sys;print(sys.platform)"
darwin  
$python -c "import sys;print(sys.version_info)"
major=3,minor=6,micro=1,releaselevel='final',serial=0  
  
退出：  
终止进程的正确做法是：调用sys.exit函数，sys.exit函数会确保退出前完成相关的清理操作。  
常见的清理操作，包括finally、atexit。finally是结构化异常子句，无论异常是否发生，finally总是被执行；atexit是注册在进程退出前才执行的清理函数。  
终止进程应该返回退出状态码（exit_status），以便命令行管理工具根据退出状态码做出判断。通常，返回0表示正常结束；返回其他值表示错误。  
标准库os模块里有部分平台的常用定义，也可以自行设定，以表达不同的结果。  
辅助函数exit、quit由site函数创建，适用于交互式环境。不建议在交互式环境中使用这些辅助函数，因为，可能导致该文件在IPython等环境下执行出错。  
os._ exit 会立即终止进程，不执行任何清理操作。  
```python  
import atexit
import sys
atexit.register(print,"atexit")
try:
    sys.exit()
finally:
    print("finally")   
    
#输出：  
>>>finally
>>>atexit
```   
$python -c "import os;exit(os.EX_DATAERR)";echo $?     #使用OS定义
>>>65  
$python -c "exit('error')";echo $?                     #非整数退出码
>>>error  
>>>1  

## 3.1.2 代码   
不应该使用辉宏的架构和过度的设计来体现优雅，而应该追求自然的逻辑抽象、最简单的代码直述。  
  
缩进：  
4个半角空格表达缩进。空格可以保证在大多数环境下的风格一致。  
python2可以混用2种风格，python3只能选中一种缩进方式。  
$python2 -t test.py    #参数-t检查缩进风格是否一致  
inconsistent use of tabs and spaces in indentation  
  
$python3 test.py  
TabERROR:inconsistent use of tabs and spaces in indentation  
缩进的麻烦在于，格式丢失，导致逻辑错误。  
```python  
def sum(x):   
    n=0
    for i in x:
        n+=i
        return n     #缩进错误，导致逻辑错误
print(sum(range(10)))
>>>0  

def sum(x):
    n=0
    for i in x:
        n+=i
    return n   
print(sum(range(10)))
>>>45
```   
由于python没有代码块结束标志，因此，可以添加注释作为排版和检查标记。当出现问题时，标记能让我们进行手工调整，这对于因网页粘贴而导致混乱的大段代码尤其有用。  
```python  
def sum(x):
    n=0
    for i in x:
        n+=i
    # end_for      #注释表示块结束。
    return n
```  
也可以创建伪关键字作为结束符号。  
```python  
import builtins
builtins.end=None   #在内置模块，为None添加一个别名。确保后续的任意模块都能使用

def sum(x):
    n=0
    for i in x:
        n+=i
    end             #块结束符号
    return n
```    
但是，python编译器并不会将这个无意义的end忽略掉，但这个end对于性能的影响微乎其微。  
如果有严格的编码习惯，可以用空行区分不同的代码块。  

语句：  
通常，代码行不宜过长，每条语句独占一行；仅仅在必要时，用分号分隔多条语句。  
单条语句超过限制宽度时，手动换行的可读性更好。  
将多条件分为多行，也易于修改，如，调整优先次序，或临时注释掉某些条件等。  
大多数编程规范将行宽限制在80字符，可以适当放宽至100字符。  
反斜线\ 续行符后，不能有空格和注释。  
```python  
if (0<a<10) and \
    (b is not None) and \
    (c in b):
```  
有成对括号的表达式，不用续行符就可以分成多行。  
```python  
a=[1,               #没有续行符，可以有注释
   2,               #多行，可以方便调整顺序，或注释掉某些初始值
   3,
   ]
  
b={
"a":1,
"b":2,
}  
  
def long_function_name(var_one,var_two,var_three,     #利用多行，将参数分组
        var_four):
    pass
```  
  
注释：  
控制注释数量，避免影响代码的修改；不应该添加冗余的注释；在修改代码时，必须同步更新注释，以避免造成误解。  
注释以#开头，作用到行尾。  
注释，分为块注释（block）、内联注释（inline）。块注释与代码块平级缩进，用于描述整块代码的逻辑意图和算法设计；内联注释，在代码行尾部，补充说明其作用。  
```python  
def test():
    #block1
    #block2
    #block3
    print("hello")
x=1           # inline comment   

```

帮助：  
帮助属于基本元数据，帮助可以在运行期查询和输出。帮助可以在交互环境下，手工查看，也可以用于编辑器智能提示，改善编码体验，或导出生成开发手册。  

帮助就是简单的字符串的字符。  
考虑到跨行的需要，帮助总是用三引号格式。  
建议为导出成员（public）添加帮助（docstrings）信息。  
文档生成可使用pydoc，或更专业的Sphinx。
```python  
"""模块帮助信息"""
def test():
    """函数帮助信息"""
    pass
```     
模块帮助信息不能放到shebang前面。   
帮助信息保存在__doc__属性里，可以直接输出，也可以以help函数查看。   

```python 
import test  

test.__doc__  
  
test.test.__doc__   #报错

help(test)    

#输出：
Help on package test:
NAME
    test - # Dummy file to make this directory a package.
PACKAGE CONTENTS
    __main__
    _test_multi...
```     
当解释器以“OO”优化方式运行时，帮助信息被移除。  
$python -c "import test;print(test.__doc__)"  
$python -OO -c "import test;print(test.__doc__)"  
>>>None  

# 3.2 赋值  
赋值操作为名字和目标对象建立关联。建立关联只是赋值的结果，或称之为基本用途。  
任何时候，代码的可读性都应该优先考虑。    

同时为多个名字建立关联。  
```python  
a=b=c=1234  

a is b is c    #引用同一目标
>>> True
```    
仅仅以逗号分隔的多个右值，被视为元组的初始元素。  
```python  
x=1,"abc",[10,20]  

x
>>>(1, 'abc', [10, 20])
```       

## 3.2.1 增量赋值    
增量赋值试图直接修改原对象内容，实现累加效果。前提是目标对象允许被修改，否则，增量赋值会退化为普通赋值。    
增量赋值需要保证目标对象存在。  
```python  
s+=10
>>>TypeError: Can't convert 'int' object to str implicitly  
  
s=0
s+=10
```   
分别以可变列表、不可变元组对比增量赋值的结果。  
```python  
a=b=[]  

a+=[1,2]
a is b      #依然指向原对象
>>>True  

a
>>>[1, 2]
b
>>>[1, 2]  
  
c=d=()
c+=(1,2)
c is d      #新对象
>>>False  

c
>>>(1, 2)  

d
>>>()
```  
对可变列表、不可变元组进行增量赋值，结果不同。  
增量赋值后，列表会直接修改原来的内容，而元组会新建对象。  
虽然编译器将增量赋值都处理为INPLACE_ADD指令，但最终执行还是依据目标类型而定。以+=为例，它对应__iadd__方法，这是能否执行增量操作的关键；如果该方法不存在，则尝试执行__add__，变成普通加法操作。  
```python  
import dis
dis.dis(compile("a+=[1,2]","","exec"))  
#输出：
  1           0 LOAD_NAME                0 (a)
              3 LOAD_CONST               0 (1)
              6 LOAD_CONST               1 (2)
              9 BUILD_LIST               2
             12 INPLACE_ADD
             13 STORE_NAME               0 (a)
             16 LOAD_CONST               2 (None)
             19 RETURN_VALUE  
             
dis.dis(compile("a+=(1,2)","","exec"))  
#输出：
  1           0 LOAD_NAME                0 (a)
              3 LOAD_CONST               3 ((1, 2))   
              6 INPLACE_ADD                        #并不能完成增量赋值
              7 STORE_NAME               0 (a)
             10 LOAD_CONST               2 (None)
             13 RETURN_VALUE
  
"__iadd__" in dir([1,2])
>>>True  

"__iadd__" in dir((1,2))
>>>False
"__add__" in dir((1,2))
>>>True
```  
  


## 3.2.2 序列解包    
不同于将多个变量名关联到单一对象，序列解包会展开所有元素，再与多个变量名关联。  
```python  
a,b,c=[1,2,3]
a,b,c
>>>(1, 2, 3)
a
>>>1  

a,b,c="xyz"
a,b,c
>>>('x', 'y', 'z')
a
>>>'x'  

a,b,c=range(3)
a,b,c
>>>(0, 1, 2)
a
>>>0
```   
等号右边的对象需要是单一元组对象。  
```python  
a,b=[1,2],(3,4)   #右值表达式构建元组对象（[1,2],(3,4)）

a
>>>[1, 2]
b
>>>(3, 4)
```   
解包操作还可以用于交换变量，不需要借助第三方。  
对于三个以内的变量交换，编译器优化成ROT指令，直接交换栈帧数据，而不是构建元组。  
```python  
a,b=b,a
dis.dis(compile("a,b,c=c,b,a","","exec"))  
#输出：
  1           0 LOAD_NAME                0 (c)
              3 LOAD_NAME                1 (b)
              6 LOAD_NAME                2 (a)
              9 ROT_THREE                        #使用ROT指令直接操作栈帧数据
             10 ROT_TWO
             11 STORE_NAME               2 (a)
             14 STORE_NAME               1 (b)
             17 STORE_NAME               0 (c)
             20 LOAD_CONST               0 (None)
             23 RETURN_VALUE    
             
dis.dis(compile("a,b,c,d=d,c,b,a","","exec"))  
#输出：
  1           0 LOAD_NAME                0 (d)
              3 LOAD_NAME                1 (c)
              6 LOAD_NAME                2 (b)
              9 LOAD_NAME                3 (a)
             12 BUILD_TUPLE              4       #构建元组，解包后分别赋值
             15 UNPACK_SEQUENCE          4
             18 STORE_NAME               3 (a)
             21 STORE_NAME               2 (b)
             24 STORE_NAME               1 (c)
             27 STORE_NAME               0 (d)
             30 LOAD_CONST               0 (None)
             33 RETURN_VALUE
```    
支持深度嵌套展开。  
左右值表达式以相同的方式嵌套。  
```python  
a,(b,c)=1,[10,20]     #简单嵌套方式
a,b,c
>>>(1, 10, 20)  

a,((b,c),(d,e))=1,[(10,20),"ab"]  #更深层次的嵌套
a,b,c,d,e
>>>(1, 10, 20, 'a', 'b')
```   
也可以忽略某些元素。  
```python  
a,_,b,_,c="a0b0c"
a,b,c
>>>('a', 'b', 'c')  

a,_,b,_,c="10203"
a,b,c
>>>('1', '2', '3')
```    
星号收集：  
当序列元素与变量名数量不等时，解析报错。  
```python  
a,b=1,2,3
>>>ValueError: too many values to unpack (expected 2)
  
a,b,c=1,2
>>>ValueError: need more than 2 values to unpack
```  
如果元素多余变量名，那么，可以将右值截取等长片段；如果变量名多余元素，则比较麻烦，需要写代码进行判断，为此，python3专门实现了扩展方式。  
在变量名前添加星号，表示收纳所有剩余元素。  
```python  
a,*b,c=range(5)
a,b,c
>>>(0, [1, 2, 3], 4)
```  
变量名多余元素时，也能处理。  
```python  
a,*b,c=1,2    

a,b,c     #收集不到数据，返回空列表
>>>(1, [], 2)
```   
解析包操作，优先保障对非收集变量名的赋值，因此，元素不能少于非收集变量名的数目。  
另外，星号只能有一个，否则，无法界定收集边界。  
```python  
a,*b,c,d=1,2
>>>ValueError: need more than 2 values to unpack
  
a,*b,*c,d=range(10)
>>>SyntaxError: two starred expressions in assignment 
```    
星号收集不能单独出现：要么与其他变量名一起，要么放入列表或元组内。  
```python  
*a=1,2
>>>SyntaxError: starred assignment target must be in a list or tuple    

[*a]=1,2
a
>>>[1, 2]  

(*a,)=1,2
a
>>>[1, 2]
```  
序列解包和星号收集符，也可以用于控制流表达式等场合。  
```python  
for a,*b in ["abc",(1,2,3)]:
    print(a,b)    
    
>>>a ['b', 'c']
>>>1 [2, 3]
```   
  
星号展开：  
星号还可以用来展开可迭代（iterable）对象。  
可迭代对象就是每次返回一个成员。  
所有有序类型、字典、集合、文件等，都是可迭代类型。  
```python  
a=[1,2]
b="ab"
c=range(10,13)
[*a,*b,*c]
>>>[1,2,'a','b',10,11,12]      #报错
```     
对于字典，单星号展开主键，双星号展开键值。  
```python  
d={"a":1,"b":2}
[*d]
>>>['a','b']   #报错
  
{"c":3,**d}
>>>{'c':3,'a':1,'b':2}    #报错
```    
星号展开可以用于函数调用，将单个对象分解成多个实参。  
```python  
def test(a,b,c):
    print(locals())  
    
test(*range(3))
>>>{'a': 0, 'c': 2, 'b': 1}
test(*[1,2],3)
>>>{'c':3,'b':2,'a':1}    #报错  
  
a={"a":1,"c":3}
b={"b":2}
test(**b,**a)  
>>>{'c':3,'b':2,'a':1}    #报错  
```  

## 3.2.3 作用域名    
作为隐式规则，赋值操作默认总是针对当前命名空间。  
同一作用域内，变量名总属于单一命名空间，变量名不会因为执行顺序而被引用到不同的命名空间。  
```python  
x=10
def test():
    print(x)
    x=x+10  
    
test()
>>>UnboundLocalError: local variable 'x' referenced before assignment  
  
  
dis.dis(test)  
#输出：
  2           0 LOAD_GLOBAL              0 (print)
              3 LOAD_FAST                0 (x)   #本地
              6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
              9 POP_TOP
  3          10 LOAD_FAST                0 (x)
             13 LOAD_CONST               1 (10)
             16 BINARY_ADD
             17 STORE_FAST               0 (x)   #本地
             20 LOAD_CONST               0 (None)
             23 RETURN_VALUE
#结果不全
```    
从反汇编结果来看，函数test内的x统统从本地变量名空间引用，而不是像设想的那样：先从全局读取，然后在本地建立关联。  
如果要对外部变量赋值，必须显式声明变量位置。关键字global指向全局命名空间，nonlocal为外层嵌套（enclosing）函数。  
除非必要，否则应该避免直接对外部变量赋值。可以直接用返回值等方式，交由持有者处理。  
```python  
g=1  

def outer():
    e=2
    def inner():
        global g      #声明全局变量
        nonlocal e    #声明外层嵌套函数变量
        g=10
        e=20  
        
    inner()
    return e  
    
outer()
>>>20  

g
>>>10
```    
显式声明指示编译器生成对外部空间的操作指令。  
```python  
def test():
    global x
    x=10
dis.dis(test)  
#输出：
  3           0 LOAD_CONST               1 (10)
              3 STORE_GLOBAL             0 (x)    #全局
              6 LOAD_CONST               0 (None)
              9 RETURN_VALUE
```  
可以用global在函数内创建全局变量。  
```python  
x
>>>NameError: name 'x' is not defined    #检查 x是否存在
  
def test():
    global x
    x=100  
    
test()
x
>>>100
```  
nonlocal，自内向外依次检索嵌套函数，但不包括全局命名空间。  
如果多层嵌套函数存在同名变量名，那么，依据就近原则处理。  
另外，nonlocal不能作为外层嵌套函数的新建变量名。  
```python  
def enclosing():
    x=1  
    def outer():
        def inner():
            nonlocal x
            x=999      #向外查找，直到 enclosing.x 命中
            
        inner()  
        
    outer()
    print(x)  
    
enclosing()
>>>999
```    
![local_nonlocal](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/3/nonlocal.jpg)  

不同于global运行期行为，nonlocal要求在编译期绑定，所以目标变量需要提前存在。  
```python  
def inner():
    nonlocal x  
  
>>>SyntaxError: no binding for nonlocal 'x' found
  
def outer():
    def inner():
        nonlocal x  
        
>>>SyntaxError: no binding for nonlocal 'x' found
```
作为写操作的赋值，规则与读操作LEGB完全不同，应区别对待。  


# 3.3 运算符     
优先级顺序和隐式转换，会导致某些隐蔽错误。  
```python  
not "a" in ["a",1]     #可读性不好
>>>False  
  
(not "a") in ["a",1]   #相同的值可能导致测试盲区
>>>False  
  
not ("a" in ["a",1])
>>>False
```  
适当使用括号，可以避免不必要的错误，同时，提高代码可读性。  
  
![picture](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/3/output.jpg)  

每个运算符都以特定的函数或者方法实现，因此，运算符可以像普通函数那样，作为参数传递。  
```python  
def calc(x,y,op):
    return op(x,y)  
    
import operator
calc(1,2,operator.add)
>>>3
calc(1,2,operator.mul)
>>>2
```   
不仅仅是数学运算符，operator、itemgetter、sttrgetter等还可以用于索引和成员访问函数。  
  
标准库还提供了辅助函数，用来简化自定义类型运算符的重载实现。  
使用functools.total_order装饰器，可以基于__eq__、__lt__，自动补全剩余方法。  
```python  
@functools.total_ordering    #报错
class X:
    def __init__(self,n):
        self.n=n
    def __eq__(self,o):
        return self.n==o.n
    def __lt__(self,o):
        return self.n<o.n
  
a,b=X(1),X(2)  

a<=b  
>>>True
a>=b  
>>>False
```  
python3对运算符做了一些调整：  
1）移除<>，统一使用 ！=运算符；  
2）移除cmp函数，必须自行重载相关运算符的方法；  
3）除法 / 表示True Division，总是返回浮点数；  
4）不再支持反引号repr操作，必须调用同名函数；  
5）不再支持非数字类型混合比较，可以自定义相关方法；  
6）不再支持字典相等以外的比较操作。  


## 3.3.1 链式比较   
链式比较将多个比较表达式组合到一起。优点是，可以缩短代码，并稍微提高性能。  
```python  
a,b=2,3  

a>0 and b>a and b<=5    #链式表达可读性好，易于维护
>>>True
```    
反汇编查看两者差异：  
```python  
dis.dis(compile("1<a and a<2","","eval"))  
#输出：
  1           0 LOAD_CONST               0 (1)
              2 LOAD_NAME                0 (a)
              4 COMPARE_OP               0 (<)
              6 JUMP_IF_FALSE_OR_POP    14
              8 LOAD_NAME                0 (a)
             10 LOAD_CONST               1 (2)
             12 COMPARE_OP               0 (<)
        >>   14 RETURN_VALUE  
        
dis.dis(compile("1<a<2","","eval"))  
#输出：
  1           0 LOAD_CONST               0 (1)
              2 LOAD_NAME                0 (a)
              4 DUP_TOP
              6 ROT_THREE
              8 COMPARE_OP               0 (<)
             10 JUMP_IF_FALSE_OR_POP    18
             12 LOAD_CONST               1 (2)
             14 COMPARE_OP               0 (<)
             16 RETURN_VALUE
        >>   18 ROT_TWO
             20 POP_TOP
             22 RETURN_VALUE
```    
链式比较，显然减少了载入指令，链式比较更多基于栈数据复制和替换。因此，执行性能有所提高。   
但是代码的可读性、可维护性更好。  

## 3.3.2 切片    
切片，用于表达序列片段或整体。  
切片的具体行为与切片在语句中的位置有关，切片作为右值时，复制序列数据；作为左值时，表达操作范围。  
```python  
x=[0,1,2,3,4,5,6]  

s=x[2:5]
s
>>>[2, 3, 4]  

x.insert(3,100)
x
>>>[0, 1, 2, 100, 3, 4, 5, 6]  

s
>>>[2, 3, 4]
```    

```python  

```    
```python  

```    

## 3.3.3 逻辑运算  

# 3.4 控制流  
## 3.4.1 选择  
## 3.4.2 循环  

# 3.5 推导式  
