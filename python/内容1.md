# 2.1 基本环境  

## 2.1.1.印象  
  从抽象角度看，每个运行的**程序（进程）**都是一定数量的**对象**组成，每个对象都有独特的状态和逻辑，通过**触发**或与其他**对象的交互**来体现。  
    
      
      
  类型（class）和实例（instance）：  
    * 1.类型是多个 实例（instance）的公共特性，实例（instance）只需要保留私有特性即可。  
    这样的好处是，内存空间布局高效。  
    * 2.每个实例都持有其类型的指针，需要时，可以通过该指针间接访问目标。  
        ![class-instance](https://github.com/tamily-duoy/learning-/blob/master/python/QQshotpic/%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AE%9E%E4%BE%8B.jpg)  
    * 3.从逻辑来看，任何实例都是完整的。原因：
    （1）存活着的 实例（instance）对象都有**唯一**的ID值。CPython用内存地址作为ID值，因此，只能保证在某个时间内，在存活对象中，该实例（instance）唯一，并不能确保整个进程的生命周期内也是唯一的。因为内存地址会被复用，因此，ID不适合作为全局身份标识。  
```python 
id(123)
>>>496481184
id(123)
>>>496481184
id([1,2,3])
>>>54861128
id("abc")
>>>31100128
```  
@tamily：**id函数**可以查看instance的内存地址，python会为每个出现的对象分配内存地址，第一次创建即出现。  

（2）可以用type返回实例所属类型。  
```python
type(0)
>>><class 'int'>
type("0")
>>><class 'str'>
type([])
>>><class 'list'>
```
（3）要判断实例是否属于特定类型，可以用isinstance函数。
```python
isinstance(1,int)
>>>True
isinstance("1",str)
>>>True
isinstance([],list)
>>>True

```
  
    
    
类型：  
类型间可以构成继承关系，任何类型都是父类型的子类。  
对象可以视为父类型的实例，这和对象三大特性中的多态有关，后面介绍。
```python
class Animal:                 #动物
    pass
class Mammal(Animal):         #哺乳动物
    pass
class Felidae(Mammal):        #猫科
    pass
class Lion(Felidae):          #狮子
    pass
class Tiger(Felidae):         #老虎
    pass
class Liger(Lion,Tiger):      #狮虎兽
    pass  
    
issubclass(Liger,Lion)
>>>True
issubclass(Liger,Tiger)
>>>True
issubclass(Liger,Animal) #是任何祖先类型的子类
>>>True  

wxh=Liger()                   #王小虎（狮虎兽实例）
isinstance(wxh,Lion)
>>>True
isinstance(wxh,Tiger)
>>>True
isinstance(wxh,Animal)   #是任何祖先类型的实例
>>>True

```
事实上，所有的类型都共用一个**公共祖先类型（object）**，公共祖先类型（object）为所有类型提供**原始模板**和系统需要的**基本操作方式**。  
```python
issubclass(Liger,object) #创建的 狮虎兽 类型，是公共祖先类型（object）的子类
>>>True
issubclass(int,object)   #系统的 int 类型，是公共祖先类型（object）的子类
>>>True


```
类型虽然是个抽象概念，但在实现时，仅仅作为**普通的对象实例**，因为所有的类型都是**由type创建**，与继承无关。  
```python
type(int)
>>><class 'type'>      #类型 由type创建
type(str)
>>><class 'type'>  

isinstance(int,type)   #类型是type的实例
>>>True
isinstance(Liger,type)
>>>True


```  
小结：所有的类型，都是公共祖先类型（object）的子类型，都是type创建的普通实例对象
就类型对象而言，本质是用来**存储**方法和字段的特殊容器。继承只能说明，两个类型在逻辑上存在关联关系，所有类型的对象都属于type实例。 
@tamily：实现上，类型是type创建的对象实例；逻辑上，类型可以继承。
编码和设计都要正确区分逻辑与实现的差异。  
存在类型对象属于创建者的情况。默认情况下，它们由解释器在首次载入时自动生成，生命周期与进程相同，仅有一个实例
```python
type(100) is type(123) is int  #指向同一类型的对象
>>>True
```

## 2.1.2变量 
变量:  
变量是一段具有特定格式的**内存**，变量名则是内存别名。  
因为在编码阶段，无法确定内存具体位置，故使用名称符号代替。  
变量名与指针不同。  

变量名的处理：  
静态编译和动态解释型语言对于变量名的处理方式完全不同：（1）静态编译器或连接器，会以固定地址直接、间接地**寻址指令替代变量名**。即，变量名不参与执行过程时，就可以被剔除。（2）解释型动态语言中，变量名和对象通常是2个运行实体。变量名不但有自己的类型，还需要分配内存，并介入执行过程。可以说，变量名才是动态模型的基础。变量名必须与目标对象关联才会起作用。  
```python
 x
>>>Traceback (most recent call last):  
File "<input>", line 1, in <module>  
NameError: name 'x' is not defined
 ```  
 
变量与对象的关联操作：  
变量与目标对象关联的直接操作是---赋值。赋值后，对变量进行的引用都可以视为对目标对象进行操作。
```python
x=100
x
>>>100  

x+=2
x
>>>102
```  
赋值步骤：（1）准备好右值目标对象（100）。（2）准备好名字（x）。（3）在命名空间内为两者建立联系（namespace{x:100}）。  
赋值，只能建立引用关联。变量名只是负责找对象，对于对象（类型）信息一无所知。在运行期才会知道变量名引用的目标类型，因而称python是一种解释型语言。  
  
    
命名空间：  





## 2.1.3内存  

## 2.1.4编译  

## 2.1.5执行
